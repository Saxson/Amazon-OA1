package gyang4.amazon;

import java.util.ArrayDeque;
import java.util.Deque;



public class RoundRobin {
    static class Process {
        int waitAt; // the time process start waiting
        int remainTime; // the remain time process need to execute
        int waitTime; // the total time process has waited
        
        public Process(int arriveAt, int executeTime) {
            waitAt = arriveAt;
            remainTime = executeTime;
        }
    }
    public static double schedule(int[] arrives, int[] executes, int q) {
        int len = arrives.length;
        Deque<Process> queue = new ArrayDeque<>();
        int totalWaiting = 0;
        int currentTime = 0;
        int finished = 0;
        int nextArrive = 0;

        while(finished < len) {
            // If queue is empty, put the first arrive process to the queue
            if (queue.isEmpty() && nextArrive < len) {
                currentTime = arrives[nextArrive];
                queue.offer(new Process(arrives[nextArrive], executes[nextArrive]));
                nextArrive++;
            }

            // Get the head of queue
            Process running = queue.poll();

            // Accumulate the waiting time
            running.waitTime += currentTime - running.waitAt;

            // If the remain time of current process is larger than the time quantum,
            // the process can be executed for one quantum, otherwise, should finish this process
            int run = Math.min(q, running.remainTime);

            // While one process running, check if there are some processes arrive
            while(nextArrive < len && arrives[nextArrive] <= currentTime + run) {
                queue.offer(new Process(arrives[nextArrive], executes[nextArrive]));
                nextArrive++;
            }

            // Update the current time and the remain time of the current time,
            // then switch to next process
            currentTime += run;
            running.remainTime -= run;

            if(running.remainTime == 0) {
                // If the current process has finished, finish it
                totalWaiting += running.waitTime;
                finished++;
            } else {
                // Otherwise, put the process to the tail of the queue
                running.waitAt = currentTime;
                queue.offer(running);
            }

        }
        return (double)totalWaiting / len;
    }

    public static void main(String[] args) {
        int[] arrives = {0,1,3,9};
        int[] executes = {2,1,7,5};

        System.out.println(schedule(arrives, executes, 2));
    }
}
